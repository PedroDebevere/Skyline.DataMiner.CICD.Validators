// <auto-generated>
// Do not change. Treat this as auto-generated code as this is converted from code in DataMiner.
// If there are software changes this allows easier comparison.
// </auto-generated>
namespace Skyline.DataMiner.CICD.Validators.Protocol.Helpers.Conditions
{
    using System;
    using System.Collections.Generic;

    using Skyline.DataMiner.CICD.Models.Protocol.Read.Interfaces;

    class Condition
    {
        private readonly List<ConditionMember> paConditionMembers;
        private readonly List<string> saStrings;

        private readonly List<ConditionOperator> uiaOperators;

        private readonly Action addConditionCanBeSimplifiedWarning;

        public Condition(string strCondition, Action addConditionCanBeSimplifiedWarning)
        {
            this.addConditionCanBeSimplifiedWarning = addConditionCanBeSimplifiedWarning;

            StrData = strCondition;

            paConditionMembers = new List<ConditionMember>();
            saStrings = new List<string>();

            uiaOperators = new List<ConditionOperator>();

            string strTmpData = strCondition;

            if (strTmpData.Length > 0)
            {
                strTmpData = strTmpData.TrimStart(new char[] { '(', ' ' });
                strTmpData = strTmpData.TrimEnd(new char[] { ')', ' ' });

                int iLeftQuote = -1;
                int iRightQuote = -1;
                int iLastOperatorPos = 0;

                iLeftQuote = strTmpData.IndexOf('"');

                // Replace all string literals in the condition with ${x}$ placeholders, where {x} denotes the index in the saStrings array.
                while (iLeftQuote != -1)
                {
                    // we have found a string
                    iRightQuote = strTmpData.IndexOf(('"'), iLeftQuote + 1);

                    if (iRightQuote == -1)
                    {
                        break;
                    }

                    string strTmpString = strTmpData.Substring(iLeftQuote + 1, (iRightQuote - iLeftQuote) - 1);
                    saStrings.Add(strTmpString);

                    string strReplacement = String.Format("${0}$", saStrings.Count - 1);

                    strTmpData = strTmpData.Remove(iLeftQuote, (iRightQuote - iLeftQuote) + 1);
                    strTmpData = strTmpData.Insert(iLeftQuote, strReplacement);

                    iLeftQuote = strTmpData.IndexOf('"');
                }

                int i = 0;
                for (i = 0; i < strTmpData.Length; i++)
                {
                    if (i + 5 <= strTmpData.Length && strTmpData.Substring(i, 5).Equals(" AND ", StringComparison.OrdinalIgnoreCase))
                    {
                        ConditionMember conditionMember = ParseConditionMember(strTmpData.Substring(iLastOperatorPos, i - iLastOperatorPos));
                        paConditionMembers.Add(conditionMember);

                        uiaOperators.Add(ConditionOperator.And);

                        iLastOperatorPos = i + 5;
                    }

                    if (i + 4 <= strTmpData.Length && strTmpData.Substring(i, 4).Equals(" OR ", StringComparison.OrdinalIgnoreCase))
                    {
                        uiaOperators.Add(ConditionOperator.Or);

                        ConditionMember conditionMember = ParseConditionMember(strTmpData.Substring(iLastOperatorPos, i - iLastOperatorPos));
                        paConditionMembers.Add(conditionMember);

                        iLastOperatorPos = i + 4;
                    }
                }

                ConditionMember lastConditionMember = ParseConditionMember(strTmpData.Substring(iLastOperatorPos, i - iLastOperatorPos));
                paConditionMembers.Add(lastConditionMember);

                uiaOperators.Insert(0, ConditionOperator.Undefined);
            }
        }

		public string StrData { get; }

		private ConditionMember ParseConditionMember(string conditionMember)
        {
            return new ConditionMember(conditionMember, saStrings, addConditionCanBeSimplifiedWarning);
        }

        public Variant Perform(Condition[] paConditions, IProtocolModel pProtocol)
        {
            bool bOk = false;

            ConditionMember pMember = null;

            Variant varResult = new Variant();

            for (int i = 0; i <= (paConditionMembers.Count - 1); i++)
            {
                varResult = new Variant();
                pMember = paConditionMembers[i];
                if (pMember != null)
                {
                    if (i == 0)
                    {
                        varResult = pMember.Perform(paConditions, pProtocol);
                        if (varResult.Type == VariantType.VT_BOOL)
                        {
                            bOk = varResult.BooleanValue.Value;
                        }
                        else
                        {
                            if (uiaOperators.Contains(ConditionOperator.And) || uiaOperators.Contains(ConditionOperator.Or))
                            {
                                throw new InvalidConditionException("Not all operands of a conditional AND or OR expression are boolean expressions.");
                            }
                        }
                    }
                    else if ((uiaOperators.Count - 1) >= i)
                    {
                        varResult = pMember.Perform(paConditions, pProtocol);
                        if (varResult.Type == VariantType.VT_BOOL)
                        {
                            if (uiaOperators[i] == ConditionOperator.And)
                                bOk &= varResult.BooleanValue.Value;
                            else if (uiaOperators[i] == ConditionOperator.Or)
                                bOk |= varResult.BooleanValue.Value;
                        }
                        else
                        {
                            if(uiaOperators[i] == ConditionOperator.And || uiaOperators[i] == ConditionOperator.Or)
                            {
                                throw new InvalidConditionException("Not all operands of a conditional AND or OR expression are boolean expressions.");
                            }
                        }
                    }
                }
            }

            if ((paConditionMembers.Count - 1) == 0)
            {
                return varResult;
            }

            Variant bRet = new Variant();
            bRet.Type = VariantType.VT_BOOL;
            bRet.BooleanValue = bOk;

            return bRet;
        }
    }
}